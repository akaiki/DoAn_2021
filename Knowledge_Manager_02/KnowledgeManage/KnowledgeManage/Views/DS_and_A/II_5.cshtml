@{
    ViewData["Title"] = "Content";
    Layout = "~/Views/DS_and_A/Menu.cshtml";
}

<div class="container">
    <h2>Các ví dụ cách tính độ phức tạp của thuật toán</h2>
    <hr />
    <p>
        Dựa trên <a href="II_4"><b>các quy tắc để xác định độ phức tạp của giải thuật</b></a>, ta có thể xác định được độ phức tạp của thuật toán theo các bước:
    </p>
    <div class="card" style="background-color: #cccccc">
        <ul class="card-body">
            <li><b>B1: </b>Gọi T là độ phức tạp của thuật toán cần tìm</li>
            <li><b>B2: </b>Tính biểu thức T bằng cách cộng thời gian thực thi của các câu lệnh trong thuật toán</li>
            <li><b>B3: </b>Xét số hạng có tốc độ tăng nhanh nhất khi n tiến đến +∞</li>
            <li><b>B4: </b>Lược bỏ các giá trị có thể lược bỏ được theo các <a href="II_4"><b>các quy tắc</b></a></li>
            <li><b>B5: </b>Giá trị số hạng cuối cùng còn sót lại chính là độ phức tạp của thuật toán cần tìm</li>
        </ul>
    </div>
    <hr />
    <h3>Ví dụ 1:</h3>
    <p>
        Lấy ví dụ về giải thuật <a href="III_1_4_5"><b>sắp xếp nổi bọt </b></a> như sau:
    </p>
    <div class="card" style="background-color: #cccccc">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
<code>void BubbleSort(int a[], int n){
    for (int i = 0; i < n - 1; i++){ // ---> O(n)
        for (int j = n - 1; j > i; j--){ // ---> O(n)
            if(a[j] < a[j-1]){   // ---> O(1)
                int temp = a[j]; // ---> O(1)
                a[j] = a[j-1];   // ---> O(1)
                a[j-1] = temp;   // ---> O(1)
            }
        }
    }
}</code> </pre>
    </div>
    <p>
        Ở phần trong khối lệnh <code>if</code>, ta thấy tất cả đều có độ phức tạp là O(1), do đó ta có thể coi khối lệnh so sánh là O(1). Tiếp đến, mối khối lệnh <code>for</code> có độ phức tạp là O(n) và do chúng lồng nhau nên theo <a href="II_4_3"><b>quy tắc nhân</b></a>, hai vòng lặp for lồng nhau sẽ có độ phức tạp là O(n²).
    </p>

    <hr />
    <h3>Ví dụ 2:</h3>
    <p>Thuật toán tính tổng các số từ 1 đến n:</p>
    <div class="card" style="background-color: #cccccc">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
<code>s=0;
for (i= 1;i<=n;i++)
    s=s+i;
</code> </pre>
    </div>
    <p>
        Vòng lặp lặp n lần phép gán <code>s=s+i</code>, nên thời gian tính toán tỉ lệ thuật với n, tức là độ phức tạp là O(n).
    </p>

    <hr />
    <h3>Ví dụ 3:</h3>
    <p>
        Đoạn chương trình sau:
    </p>
    <div class="card" style="background-color: #cccccc">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
<code>for(i = 1; i < n; i++){
    for(j = 1; j <= m; j++){
        for (k = 1; k <= x; k++){
            //lệnh
        }
        for (h = 1; h <= y; h++){
            //lệnh
        }
    }
}
</code> </pre>
    </div>
    <p>
        Ta nhận thấy lệnh <code>for (k ...</code> và <code>for (h...</code> là 2 khối lệnh liền kề nhau nên ta áp dụng <a href="II_4_2"><b>quy tắc cộng - max</b></a>, ta tính được độ phức tạp của 2 khối đó là O(max(x,y)).
        Do ta gom lại cả 2 khối lệnh <code>for (k...</code> và <code>for (h...</code> lại làm một khối lớn với độ phức tạp là O(max(x, y)), nên bài toán đưa về 3 khối lệnh lồng nhau, theo <a href="II_4_3"><b>quy tắc nhân</b></a>, ta tính được độ phức tạp của cả dòng lệnh trên là <b>O(n*m*max(x, y))</b>

    </p>
    <hr />
    <p>
        Bạn có thể tham khảo các mục sau:
    </p>
    <ul>
        <li><a href="II"><b>Độ phức tạp của thuật toán</b></a></li>
        <li><a href="I_3_2"><b>Big Oh Notation, &Omicron; trong Cấu trúc dữ liệu và giải thuật</b></a></li>
        <li><a href="I_3_5"><b>Ví dụ độ phức tạp trong cấu trúc dữ liệu và giải thuật</b></a></li>
        <li><a href="II_4"><b>Các quy tắc để xác định độ phức tạp của giải thuật</b></a></li>
    </ul>
</div>