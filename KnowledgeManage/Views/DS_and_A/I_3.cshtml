
@{
    ViewData["Title"] = "I_3";
    Layout = "~/Views/DS_and_A/Menu.cshtml";
}

<style>
    .zoom {
        /*padding: 50px;*/
        background-color: green;
        transition: transform .2s; /* Animation */
        margin: 0 auto;
    }

        .zoom:hover {
            transform: scale(1.2); /* (120% zoom - Note: if the zoom is too large, it will go outside of the viewport) */
        }

    img {
        display: inline-block;
        max-width: 100%;
        max-height: 100%;
        display: block;
        margin: 0 auto;
    }
</style>
<div style="padding-left: 15%; padding-right: 15%; ">
    <h1>CẤU TRÚC DỮ LIỆU DANH SÁCH LIÊN KẾT</h1>
    <div class="container" id="I_3_1">
        <h3>Khái niệm</h3>
        <p>Một danh sách liên kết (linked list) là một dãy các cấu trúc dữ liệu được kết nối với nhau thông qua các liên kết (link). Nghĩa là danh sách liên kết là một cấu trúc dữ liệu bao gồm một nhóm các nút (node) liên kết với nhau tạo thành một chuỗi. Mỗi nút gồm dữ liệu ở nút đó và tham chiếu đến nút tiếp theo trong chuỗi.</p>
        <p>Mặc dù cùng là cấu trúc dữ liệu bao gồm một tập các phần tử, nhưng giữa danh sách liên kết và mảng có một số điểm khác biệt sau: </p>
        <ul>
            <li>
                <p>- Mảng có thể được truy cập ngẫu nhiên thông quan chỉ số, còn danh sách chỉ có thể truy cập tuần tự. Trong danh sách liên kết, muốn truy cập tới một phần tử thì phải bắt đầu từ đầu danh sách sau đó lần lượt qua các phần tử kế tiếp cho đến khi hết phần tử cần truy cập.</p>
            </li>
            <li>
                <p>- Việc bố trí, sắp xếp lại các phần tử trong một danh sách liên kết đơn giản hơn nhiều so với mảng, Bởi vì đối với danh sách liên kết, để thay đôi vị trí của một phần tử, ta chỉ cần thay đổi các liên kết cảu một số phần tử có liên quan, còn trong mảng, ta thường phải thay đổi vị trí của rất nhiều phần tử.</p>
            </li>
            <li>
                <p>- Do bản chất động của danh sách liên kết, kích thước của danh sách liên kết có thể linh hoạt hơn nhiều so với mảng, Kích thước của danh sách không cần phải khai báo trước, bất kỳ lúc nào có thể tạo mới một phần tử và thêm vào vị trí bất kì trong danh sách. Nói cách khác, mảng là một tập hợp cố định các phần tử, còn danh sách liên kết là một tập có số lược phần tử không cố định.</p>
            </li>
        </ul>
        <p>Các loại danh sách liên kết: </p>
        <ul>
            <li>
                <p><a href="#I_3_2">Danh sách liên kết đơn (Simple Linked List)</a>: Chỉ duyệt các phần tử theo chiều về trước.</p>
            </li>
            <li>
                <p><a href="#I_3_3">Danh sách liên kết đôi (Doubly Linked List)</a>: Các phần tử có thể được duyệt theo chiều từ về trước hoặc về sau.</p>
            </li>
            <li>
                <p><a href="#I_3_4">Danh sách liên kết vòng (Circular Linked List)</a>: Phần tử cuối cùng chứa link của phần tử đầu tiên như là next và phần tử đầu tiên có link tới phần tử cuối cùng như là prev.</p>
            </li>
        </ul>
    </div>
    <hr />
    <div class="container" id="I_3_2">
        <h3>Danh sách liên kết đơn</h3>
        <div class="container" id="I_3_2_1">
            <h5>Khái niệm danh sách liên kết đơn</h5>
            <p>Danh sách liên kết đơn là danh sách liên kết chỉ duyệt các phần tử theo chiều về trước. Danh sách liên kết đơn là mặc định khi nhắc tới danh sách liên kết.</p>
            <img src="~/Image/linkedlist.jpg" alt="LinkedList" class="zoom" style="text-align:center" />
            <p style="text-align:center"><i>Hình biểu diễn cho danh sách liên kết đơn</i></p>
        </div>
        <div class="container" id="I_3_2_2">
            <h5>Biểu diễn danh sách liên kết đơn</h5>
            <p>Để khai báo một danh sách trong C, ta có thể dùng cấu trúc tự trỏ. Ví dụ, để khai báo một danh sách liên kết mà mỗi nút chứa một phần tử là sô nguyên như sau:</p>
            <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                <code>
    struct node {
        int item;
        struct node *next;
    };
    typedef struct node *listnode;</code> </pre>
            </div><br />
            <p>Ngoài ra, có thể tạo, cấp phát và giải phóng bộ nhớ cho 1 nút (node):</p>
            <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                <code>
    listnode p; //Khai báo biến p

    p = (listnode)malloc(sizeof(struct node)); // cấp phát bộ nhớ cho p

    free(p); //giải phóng bộ nhớ đã cấp phát cho nút p</code> </pre>
            </div><br />
        </div>
        <div class="container" id="I_3_2_3">
            <h5>Các hoạt động trên danh sách liên kết đơn</h5>
            <p>Sau đây là một số hoạt động cơ bản có thể được thực hiện bởi một danh sách liên kết: </p>
            <ul>
                <li>
                    <p><a href="#dslk_don_chen">Hoạt động chèn:</a>thêm một phần tử vào đầu danh sách, cuối danh sách hoặc trước node bất kì.</p>
                </li>
                <li>
                    <p><a href="#dslk_don_xoa">Hoạt động xóa:</a> xóa một phần tử vào đầu danh sách, cuối danh sách hoặc trước node bất kì.</p>
                </li>
                <li>
                    <p><a href="#dslk_don_duyet">Duyệt toàn bộ danh sách: </a>duyệt qua taonf bộ các phần tử của danh sách, từ phần tử đầu tiên cho đến phần tử cuối cùng.</p>
                </li>
            </ul>
            <hr />
            <div id="dslk_don_chen">
                <h5>Hoạt động chèn</h5>
                <p>
                    Trong hoạt động chèn, ta có thể:
                    <ul>
                        <li><a href="#dslk_don_chen_a">a. Chèn một nút vào đầu danh sách</a></li>
                        <li><a href="#dslk_don_chen_b">b. Chèn một nút vào cuối danh sách</a></li>
                        <li><a href="#dslk_don_chen_c">c. Chèn một nút vào trước nút r trong danh sách</a></li>
                    </ul>
                </p>

                <div id="dslk_don_chen_a">
                    <p><b>a. Chèn một nút vào đầu danh sách</b></p>

                    <p>Giả sử ta có một danh sách mà đầu vào được trỏ tới bởi con trỏ p</p>
                    <img src="~/Image/list_insert_begin_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Các bước để chèn một nút mới vào đầu danh sách như sau: </p>

                    <p>B1: Tạo và cấp phát bộ nhớ cho 1 nút mới. Nút này được trỏ tới bởi q.</p>
                    <img src="~/Image/list_insert_begin_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B2: Sau khi gán các giá trị thích hợp cho phần tử của nút mới, cho con trỏ tiếp của nút mới trỏ đến phần tử đầu tiên của nút.</p>
                    <img src="~/Image/list_insert_begin_3.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B3: Để p vẫn trỏ đến nút đầu danh sách, ta cần trỏ p đến nút mới tạo.</p>
                    <img src="~/Image/list_insert_begin_4.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p class="alert-warning">Chú ý rằng các bước trên phải làm đúng trình tự, nếu làm sai sẽ dẫn đến mất dữ liệu. Chẳng hạn, nếu ta cho con trỏ p đến nút mới tạo trước, thì khi đó nút mới tạo sẽ không trỏ tới được nút đầu danh sách cũ vì không còn biến nào lưu trữ vị trí này nữa.</p>

                    <p>Dưới đây là code mẫu theo ngôn ngữ C:</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Insert_Begin(listnode *p, int x) {
        listnode q;
        q = (listnode)malloc(sizeof(struct node));
        q -> item = x;
        q -> next = *p;
        *p = q;
    }</code> </pre>
                    </div><br />
                </div>
                <br />
                <div id="dslk_don_chen_b">
                    <p><b>b. Chèn một nút vào cuối danh sách</b></p>

                    <p>Giả sử ta có một danh sách mà đầu vào được trỏ tới bởi con trỏ p</p>
                    <img src="~/Image/list_insert_begin_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Các bước để chèn một nút mới vào cuối danh sách như sau:</p>

                    <p>B1: Tạo và cấp phát bộ nhớ cho 1 nút mới. Nút này được trỏ tới bởi q.</p>
                    <img src="~/Image/list_insert_end_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B2: Dịch chuyển con trỏ tới nút cuối của danh sách. Để làm được việc này, ta phải khai báo một biến con trỏ r. Bạn đầu, biến này cũng trỏ đến đầu danh sách như p. Lần lượt dịch chuyển r theo các nút kế tiếp cho đến khi đến cuối danh sách.</p>
                    <img src="~/Image/list_insert_end_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B3: Cho con trỏ tiếp của nút cuối (được trỏ bởi r) trỏ đến nút mới tạo là q, và con trỏ tiếp của q trỏ tới null.</p>
                    <img src="~/Image/list_insert_end_3.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Dưới đây là code mẫu theo ngôn ngữ C:</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Insert_End(listnode *p, int x) {
        listnode q, r;
        q = (listnode)malloc(sizeof(struct node));
        q -> item = x;
        q -> next = NULL;
        if (*p == NULL) *p = q;
        else{
            r = *p;
            while (r -> next != NULL) r = r -> next;
            r -> next = q;
        }
    }</code> </pre>
                    </div><br />
                </div>
                <br />
                <div id="dslk_don_chen_c">
                    <p><b>c. Chèn một nút trước nút r trong danh sách</b></p>

                    <p>Giả sửa ta có 1 danh sách mà đầu của danh sách được trỏ tới bởi con trỏ p, và 1 nút r ở giữa danh sách</p>
                    <img src="~/Image/list_insert_mid_1.jpg" class="zoom" style="text-align:center" />
                    <p>Các bước để chèn 1 nút mới vào trước nút r trong danh sách như sau:</p>

                    <p>B1: Tạo và cấp phát bộ nhớ cho 1 nút mới. Nút này được trỏ tới bởi q.</p>
                    <img src="~/Image/list_insert_mid_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B2: Cho con trỏ tiếp của nút mới trỏ đến nút kế tiếp cảu nút r.</p>
                    <img src="~/Image/list_insert_mid_3.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B3: Cho con trỏ tiếp của nút r trỏ đến q.</p>
                    <img src="~/Image/list_insert_mid_4.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Dưới đây là code mẫu theo ngôn ngữ C:</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Insert_Middle(listnode *p, int position, int x) {
        int count = 1, found = 0;
        listnode q, r;
        r = *p;
        while ((r != NULL) && (found == 0)){
            if (count == position){
                q = (listnode)malloc(sizeof(struct ndoe));
                q -> item = x;
                q -> next = r -> next;
                r -> next = q;
                found = 1;
            }
            count ++;
            r = r -> next;
        }
        if (found == 0)
            printf("Khong tim thay vi tri can chen!");
    }</code> </pre>
                    </div><br />
                    <p class="alert-warning">Chú ý rằng trong hàm này, ta giả sử rằng cần phải xác định nút r trong xâu tại 1 vị trí cho trước position. Sau đó mới tiến hành chèn nút mới vào trước nút r.</p>
                </div>
            </div>
            <hr />
            <div id="dslk_don_xoa">
                <h5>Hoạt động xóa</h5>
                <p>
                    Cũng giống như <a href="#dslk_don_chen">chèn node</a>, hoạt động xóa của danh sách liên kết cũng có các hoạt động:
                    <ul>
                        <li><a href="#dslk_don_xoa_a">a. Xóa một nút ở đầu danh sách</a></li>
                        <li><a href="#dslk_don_xoa_b">b. Xóa một nút ở cuối danh sách</a></li>
                        <li><a href="#dslk_don_xoa_c">c. Xóa một nút ở trước nút r trong danh sách</a></li>
                    </ul>
                </p>

                <p class="alert-warning">Chú ý rằng để xóa 1 nút trong danh sách thì danh sách đó không được rỗng !</p>
                <div id="dslk_don_xoa_a">
                    <p><b>a. Xóa một nút ở đầu danh sách</b></p>
                    <p>Giả sử ta có 1 danh sách mà đầu của danh sách được trỏ tới bởi con trỏ p.</p>
                    <img src="~/Image/list_insert_begin_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Các bước để xóa 1 nút ở đầu danh sách như sau:</p>

                    <p>B1: Dùng 1 con trỏ tạm q trỏ đến đầu danh sách.</p>
                    <img src="~/Image/list_remove_begin_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B2: Dịch chuyển con trỏ p qua phần tử đầu tiên đến phần tử kế tiếp.</p>
                    <img src="~/Image/list_remove_begin_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B3: Ngắt liên kết của biến tạp q với nút tiếp theo, giải phóng bộ nhớ cho q.</p>
                    <img src="~/Image/list_remove_begin_3.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Dưới đây là code mẫu theo ngôn ngữ C:</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Remove_Begin(listnode *p) {
        listnode q;
        if (*p == NULL) return;
        q = *p;
        *p = (*p) -> next;
        q => next = NULL;
        free(q);
    }</code> </pre>
                    </div><br />
                </div>
                <div id="dslk_don_xoa_b">
                    <p><b>b. Xóa một nút ở cuối danh sách</b></p>
                    <p>Giả sử ta có 1 danh sách mà đều cảu danh sách được trỏ bởi con trỏ p.</p>
                    <img src="~/Image/list_insert_begin_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Các bước để xóa 1 nút ở cuối danh sách như sau:</p>
                    <p>B1: Dịch chuyển con trỏ tới nút gần nút cuối của danh sách. Để làm được như vậy, ta cần 2 biên tạm là q và r. Lần lượt dịch chuyển q và r từ đầu danh sách tới cuối danh sách, trong đó q luôn dịch chuyển sau r 1 nút. Khi r tới nút cuối cùng thì q cũng là ở nút gần cuối cùng.</p>
                    <img src="~/Image/list_remove_end_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Cho con trỏ tiếp của nút q (nút gần cuối cùng đang được trỏ bởi q) tới NULL. Giải phóng bộ nhớ cho nút cuối cùng (đang được trỏ bởi r).</p>
                    <img src="~/Image/list_remove_end_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Dưới đây là code mẫu theo ngôn ngữ C:</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Remove_End(listnode *p) {
        listnode q, r;
        if (*p == NULL) return;
        if ((*p -> next) == NULL){
            Remove_Begin(*p);
            return;
        }
        r = *p;
        while (r -> next != NULL){
            q = r;
            r = r -> next;
        }
        q -> next = NULL;
        free(r)
    }</code> </pre>
                    </div><br />
                </div>
                <div id="dslk_don_xoa_c">
                    <p><b>c. Xóa một nút ở trước nút r trong danh sách</b></p>
                    <p>Giả sử ta có 1 danh sách mà đầu của danh sách được trỏ bới con trỏ p,và 1 nút r trong danh sách.</p>
                    <img src="~/Image/list_remove_mid_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Ta giả thiết rằng nút r không phải là nút cuối cùng của danh sách, vì nếu vậy sẽ không có nút đứng trước r nữa.</p>
                    <p>Các bước để xóa 1 nút ở trước nút r trong danh sách như sau:</p>
                    <p>B1: Sử dụng 1 biến tạm q trỏ đến đứng trước nút r.</p>
                    <img src="~/Image/list_remove_mid_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Cho con trỏ tiếp của nút r trỏ tới nút đứng sau nút q.</p>
                    <img src="~/Image/list_remove_mid_3.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Ngắt liên kết của nút q và giải phóng bộ nhớ cho q.</p>
                    <img src="~/Image/list_remove_mid_4.jpg" class="zoom" style="text-align:center" />
                    <br /><p>Dưới đây là code mẫu theo ngôn ngữ C:</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Remove_Middle(listnode *p, int position) {
        int count = 1, found = 0;
        listnode q, r;
        r = *p;
        while ((r != NULL) && (found = 0)){
            if( count == position){
                q = r -> next;
                r -> next = q ->next;
                q -> next = NULL;
                free(q);
                found = 1;
            }
            count ++;
            r = r -> next;
        }
        if (found == 0){
            printf("Khong tim thay vi tri can xoa")
        }
    }</code> </pre>
                    </div><br />
                </div>
            </div>
            <hr />
            <div id="dslk_don_duyet">
                <h5>Hoạt động duyệt</h5>
                <p>Thao tác duyệt danh sách cho phép duyệt qua toàn bộ các phần tử của danh sách, từ phần tử đầu tiên cho tới phần tử cuối cùng.</p>
                <p>Để thực hiện thao tác này, ta cần một biến tạm r trỏ tới đầu danh sách. Từ vị trí này, theo liên kết của các nút, thực hiện duyệt qua từng phần tử trong danh sách. Trong quá trình duyệt, tại mỗi nút ta có thể thực hiện các thao tác cần thiết như lấy thông tin phần tử, sửa thông tin, so sánh,...</p>
                <img src="~/Image/list_list.jpg" class="zoom" style="text-align:center" />
                <br />
                <p>Dưới đây là code mẫu theo ngôn ngữ C:</p>
                <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                    <code>
    r = p;
    while (r -> next != NULL){
        //thực hiện những thao tác cần thiết 
        r = r -> next;
    }</code> </pre>
                </div><br />
            </div>
        </div>
    </div>
    <hr />
    <div class="container" id="I_3_3">
        <h3>Danh sách liên kết đôi</h3>
        <div class="container" id="I_3_3_1">
            <h5>Khái niệm danh sách liên kết đôi</h5>
            <p>So với danh sách liên kết đơn, danh sách liên kết đôi hay danh sách liên kết kép sẽ chứa thêm một con trỏ phụ, thường được gọi là previous pointer (con trỏ trỏ đến trước đó). Con trỏ này cùng với con trỏ next và phần chứa data của node sẽ là những thành phần tạo nên một danh sách liên kết đôi. Sau đây là minh họa cho danh sách liên kết đôi:</p>
            <img src="~/Image/dou_list.jpg" class="zoom" style="text-align:center" />
            <p style="text-align:center"><i>Hình biểu diễn cho danh sách liên kết đôi</i></p>
        </div>
        <div class="container" id="I_3_3_2">
            <h5>Biểu diễn danh sách liên kết đôi</h5>
            <p>Dưới đây là code cài đặt một node của danh sách liên kết đôi bằng ngôn ngữ C:</p>
            <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                <code>
    struct Node {
        int data;
        struct Node* next;
        struct Node* prev;
    };
    typedef struct node *listnode;</code> </pre>
            </div><br />
        </div>
        <div class="container" id="I_3_3_3">
            <h5>Các hoạt động trên danh sách liên kết đôi</h5>
            <p>Cũng như <a href="#I_3_2">danh sách liên kết đơn</a>, danh sách liên kết đôi cũng có các hoạt động cơ bản sau:</p>
            <ul>
                <li>
                    <p><a href="#dslk_doi_chen">Hoạt động chèn:</a> thêm một phần tử vào đầu danh sách, cuối danh sách hoặc trước node bất kì.</p>
                </li>
                <li>
                    <p><a href="#dslk_doi_xoa">Hoạt động xóa:</a> xóa một phần tử vào đầu danh sách, cuối danh sách hoặc trước node bất kì.</p>
                </li>
                <li>
                    <p><a href="#dslk_doi_duyet">Duyệt toàn bộ danh sách: </a>duyệt qua toàn bộ các phần tử của danh sách, từ phần tử đầu tiên cho đến phần tử cuối cùng.</p>
                </li>
            </ul>
            <hr />
            <div id="dslk_doi_chen">
                <h5>Hoạt động chèn</h5>
                <p>
                    Trong hoạt động chèn, ta có thể:
                    <ul>
                        <li><a href="#dslk_doi_chen_a">a. Chèn một nút vào đầu danh sách</a></li>
                        <li><a href="#dslk_doi_chen_b">b. Chèn một nút vào cuối danh sách</a></li>
                        <li><a href="#dslk_doi_chen_c">c. Chèn một nút vào trước 1 nút trong danh sách</a></li>
                    </ul>
                </p>
                <div id="dslk_doi_chen_a">
                    <p><b>a. Chèn một nút vào đầu danh sách</b></p>
                    <p>Giả sử ta có danh sách liên kết đôi như sau:</p>
                    <img src="~/Image/dll_insert_begin_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Các bước để chèn một nút mới vào đầu danh sách như sau: </p>
                    <p>B1: Cấp phát bộ nhớ cho node mới, và truyền dữ liệu vào nó.</p>
                    <img src="~/Image/dll_insert_begin_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B2: Cho con trỏ next của node mới trỏ đến con trỏ head của danh sách liên kết đôi ban đầu. Đồng thời prev của node đầu chuyển từ trỏ tới NULL thành trỏ thới next của node mới.</p>
                    <img src="~/Image/dll_insert_begin_3.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B3: Chuyển con trỏ Head trỏ sang prev của node mới.</p>
                    <img src="~/Image/dll_insert_begin_4.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Dưới đây là code mẫu theo ngôn ngữ C:</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Insert_Begin(struct Node** head_ref, int new_data) {
        //Tạo node mới và gán dữ liệu vào
        struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
        new_node -> data = new_data;
        
        //Cho con trỏ next của node mới trỏ đến con trỏ head của danh sách liên kết đôi ban đầu
        new_node -> next = (*head_ref);
        new_node -> prev = NULL;
        
        //Con trỏ prev của node head trỏ đến node mới
        if ((*head_ref) != NULL)
            (*head_ref) -> prev = new_node;

        //Con trỏ head trỏ đến node mới
        (*head_ref) = new_node;
    }</code> </pre>
                    </div><br />
                </div>
                <br />
                <div id="dslk_doi_chen_b">
                    <p><b>b. Chèn một nút vào cuối danh sách</b></p>
                    <p>Giả sử ta có một danh sách liên kết đôi sau:</p>
                    <img src="~/Image/dll_insert_end_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Các bước để chèn một nút mới vào cuối danh sách như sau: </p>
                    <p>B1: Cấp phát bộ nhớ cho node mới, và truyền dữ liệu vào nó.</p>
                    <img src="~/Image/dll_insert_end_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B2: Nếu danh sách ban đầu đang trống, ta sẽ làm cho node mới trở thành node head của danh sahcs mới luôn. tức là làm cho con trỏ head của danh sách mới trỏ đến node mới. Nếu danh sách ban đầu không trống, ta sẽ duyệt tưới node cuối cùng của danh sách ban đầu</p>
                    <p>Thay đổi con trỏ next của node cuối cùng của danh sách ban đầu để trỏ con trỏ next này trỏ đến node mới</p>
                    <img src="~/Image/dll_insert_end_3.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B3: Làm cho node cuối của danh sách ban đầu thành node gần cuối, tức là làm cho con trỏ prev của node mới trỏ đến node này</p>
                    <img src="~/Image/dll_insert_end_4.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Dưới đây là code mẫu theo ngôn ngữ C:</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Insert_End(struct Node** head_ref, int new_data) {
        //Tạo node mới và gán dữ liệu vào
        struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
        new_node -> data = new_data;
        
        struct Node* last = *head_ref;    

        new_node -> next = NULL; // do là node cuối nên next trỏ tới NULL

        if(*head_ref == NULL){
            new_node -> prev = NULL;
            *head_ref = new_node;
            return;
        }

        //Đi tới node cuối của danh sách ban đầu
        while(last -> next == NULL)
            last = last -> next;
        
        //Con trỏ next của node cuối cùng trỏ tới node mới
        last -> next = new_node;
        //Làm cho node mới thành prev node của node cuối của danh sách ban đầu
        new_node -> prev = last;
        return;
    }</code> </pre>
                    </div><br />
                </div>
                <br />
                <div id="dslk_doi_chen_c">
                    <p><b>c. Chèn một nút vào trước 1 nút trong danh sách</b></p>
                    <p>Giả sử ta có một danh sách liên kết đôi sau:</p>
                    <img src="~/Image/dll_insert_mid_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B1: Kiểm tra xem prev_node nhận vào có NULL hay không, nếu NULL thì return</p>
                    <br />
                    <p>B2: Cấp phát bộ nhớ cho node mới, và truyền dữ liệu vào nó.</p>
                    <img src="~/Image/dll_insert_mid_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B3: Làm cho con trỏ next của node mới trỏ đến con trỏ next của prev_node</p>
                    <img src="~/Image/dll_insert_mid_3.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B4: Làm cho con trỏ next của prev_node trỏ đến node mới</p>
                    <img src="~/Image/dll_insert_mid_4.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B5: Làm cho con trỏ prev của node mới được chèn vào trỏ đến node prev_node. Hay nói cách khác là làm cho prev_node trỏ thành node trước đó của node mới</p>
                    <img src="~/Image/dll_insert_mid_5.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B6: Làm cho con trỏ prev của con trỏ next của node mới trỏ đến chính node mới</p>
                    <img src="~/Image/dll_insert_mid_6.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Dưới đây là code mẫu theo ngôn ngữ C:</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Insert_Mid(struct Node** head_ref, int new_data) {
        //Kiểm tra xem prev_node nhận vào có NULL hay không, nếu NULL thì return
        if (prev_node == NULL){
            printf("Prev_node khong the NULL");
            return;
        }
        //Tạo node mới và gán dữ liệu vào
        struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
        new_node -> data = new_data;
        
        //Làm cho con trỏ next của node mới trỏ đến con trỏ next của prev_node
        new_node -> next = prev_node -> next;
        
        //Làm cho prev_node trở thành node trước đó của node mới
        prev_node -> next = new_node;
        new_node -> prev = prev_node;

        //Làm cho con trỏ prev của con trỏ next của node mới trỏ đến chính node mới
        if (new_node -> next != NULL)
            new_node -> next -> prev = new_node;        
    }</code> </pre>
                    </div><br />
                </div>
            </div>
            <hr />
            <div id="dslk_doi_xoa">
                <h5>Hoạt động xóa</h5>
                <p>
                    Cũng giống như <a href="#dslk_doi_chen">chèn node</a>, hoạt động xóa của danh sách liên kết đôi cũng có các hoạt động:
                    <ul>
                        <li><a href="#dslk_doi_xoa_a">a. Xóa một nút ở đầu danh sách</a></li>
                        <li><a href="#dslk_doi_xoa_b">b. Xóa một nút ở cuối danh sách</a></li>
                        <li><a href="#dslk_doi_xoa_c">c. Xóa một nút ở trước 1 nút trong danh sách</a></li>
                    </ul>
                </p>
                <div id="dslk_doi_xoa_a">
                    <p><b>a. Xóa một nút ở đầu danh sách</b></p>
                    <p>Giả sử ta có danh sách liên kết đôi sau: </p>
                    <img src="~/Image/dll_remove_begin_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Để xóa một nút trong đầu danh sách liên kết đôi, ta thực hiện các bước sau:</p>
                    <p>B1: Kiểm tra xem trong danh sách có phần tử nào không. Nếu danh sách rống thì ta return. Ngược lại, nếu danh sách có phần tử thì ta thực hiện xóa node.</p>
                    <p>B2: Dịch chuyển con trỏ head trỏ đến node kế tiếp</p>
                    <img src="~/Image/dll_remove_begin_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B3: Cho con trỏ prev của con trỏ head trỏ đến null</p>
                    <img src="~/Image/dll_remove_begin_3.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Dưới đây là code mẫu :</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Remove_Begin(Node** head_ref, Node* del) {
        if (*head_ref == NULL){
            return;
        }

        //Do xóa node đầu nên del == head_ref
        *head_ref = del -> next;
        *head_red -> prev = NULL;
        free(del);
    }</code> </pre>
                    </div><br />
                </div>
                <div id="dslk_doi_xoa_b">
                    <p><b>b. Xóa một nút ở cuối danh sách</b></p>
                    <p>Giả sử ta có một danh sách liên kết đôi sau:</p>
                    <img src="~/Image/dll_remove_end_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Để xóa một node ở cuối danh sách liên kết đôi, tương tự như xóa node đầu danh sách, đầu tiên ta cần kiểm tra xem danh sách có phần tử hay không. Nếu không thì ta return. Ngược lại nếu danh sách có phần tử thì ta thực hiện các bước sau: </p>
                    <p>B1: Dịch chuyển node tail về trước đó</p>
                    <img src="~/Image/dll_remove_end_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B2: Cho con trỏ next của tail về null</p>
                    <img src="~/Image/dll_remove_end_3.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Dưới đây là code mẫu :</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Remove_Begin(Node** tail_ref, Node* del) {
        if (*tail_ref == NULL){
            return;
        }
            
        del -> next -> prev = del -> prev;

        //Nghĩa là khi node cần xóa là node cuối (del -> next == NULL)
        // ((del -> next) -> NULL) là node cuối cùng của danh sách liên kết

        *tail_red -> next = NULL;
        free(del);
    }</code> </pre>
                    </div><br />
                </div>
                <div id="dslk_doi_xoa_c">
                    <p><b>c. Xóa một nút ở trước 1 nút trong danh sách</b></p>
                    <p>Giả sử ta có một danh sách liên kết kép với node cần xóa là del</p>
                    <img src="~/Image/dll_remove_mid_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Để xóa một node giữa danh sách, ta thực hiện những bước sau:</p>
                    <p>B1: Nếu node cần xóa (del) có del -> prev == NULL thì node cần xóa là node đầu, nghĩa là ta trở về trường hợp <a href="#dslk_doi_xoa_a">xóa node đầu danh sách</a>.</p>
                    <p>B2: Nếu node cần xóa (del) có del -> next == NULL thì node cần xóa là node đầu, nghĩa là ta trở về trường hợp <a href="#dslk_doi_xoa_b">xóa node cuối danh sách</a>.</p>
                    <p>B3: Cho con trỏ prev của con trỏ tiếp theo của node cần xóa trỏ về prev của node cần xóa </p>
                    <img src="~/Image/dll_remove_mid_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B4: Cho con trỏ next của con trỏ phía sau của node cần xóa trỏ về next của node cần xóa</p>
                    <img src="~/Image/dll_remove_mid_3.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B5: Xóa node cần xóa</p>
                    <img src="~/Image/dll_remove_mid_4.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Dưới đây là code mẫu :</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Remove_Mid(Node** head_ref, Node* del) {
        if (*head_ref == NULL){
            return; //Danh sách rỗng thì returrn 
        }
            
        if (del -> next != NULL){
            del -> next -> prev = del -> prev;
            // (del -> next) là node kế tiếp của node cần xóa
            // (del -> next) -> prev: trỏ prev của node kế tiếp của node cần xóa
        } 

        if (del -> prev != NULL){
            del -> prev -> next = del -> next;
            // (del -> prev) là node trước đó của node cần xóa
            // (del -> prev) -> next: trỏ next của node kế tiếp của node cần xóa
        }

        free(del);
    }</code> </pre>
                    </div><br />

                </div>
            </div>
            <hr />
            <div id="dslk_doi_duyet">
                <h5>Hoạt động duyệt toàn bộ danh sách</h5>
                <p>Khác với duyệt danh sách liên kết đơn, danh sách liên kết đôi có thể dễ dàng duyệt cả 2 chiều:</p>
                <ul>
                    <li><a href="#dslk_doi_duyet_a">Duyệt từ đầu tới cuối:</a> Duyệt từ node head cho tới trước khi gặp node null bằng cách cùng con trỏ next</li>
                    <li><a href="#dslk_doi_duyet_b">Duyệt từ cuối về đầu:</a> Duyệt từ node tail cho tới trước khi gặp node null bằng cách cùng con trỏ prev</li>
                </ul>
                <hr />
                <div id="dslk_doi_duyet_a">
                    <p><b>Duyệt từ đầu tới cuối</b></p>
                    <p>Dưới đây là code mẫu:</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    r = head;
    while (r -> next != NULL){
        //thực hiện những thao tác cần thiết 
        r = r -> next;
    }</code> </pre>
                    </div><br />
                </div>
                <hr />
                <div id="dslk_doi_duyet_b">
                    <p><b>Duyệt từ cuối về đầu</b></p>
                    <p>Dưới đây là code mẫu:</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>r = head;
    while (r -> prev != NULL){
        //thực hiện những thao tác cần thiết 
        r = r -> prev;
    }</code> </pre>
                    </div><br />
                </div>
            </div>
        </div>
    </div>
    <hr />
    <div class="container" id="I_3_4">
        <h3>Danh sách liên kết vòng</h3>
        <div class="container" id="I_3_4_1">
            <h5>Khái niệm danh sách liên kết vòng</h5>
            <p>Danh sách liên kết vòng là một loại đặc biệt của danh sách liên kết. Danh sách liên kết vòng được tạo ra bằng cách trỏ con trỏ cuối của các danh sách trỏ lên về đầu danh sách.</p>
        </div>
        <div class="container" id="I_3_4_2">
            <h5>Biểu diễn danh sách liên kết vòng</h5>
            <p>Do tính chất của danh sách liên kết vòng, danh sách liên kết vòng được chia làm 2 loại là:</p>
            <ul>
                <li id="vongdon_bieudien">
                    <b>Danh sách liên kết vòng đơn</b>
                    <p>Danh sách liên kết vòng đơn được tạo bằng cách thay vì node cuối trỏ tới NULL thì node cuối được trỏ trở lại node đầu</p>
                    <p>Vì vậy, cách khai báo danh sách liên kết vòng đơn sẽ giống như cách khai báo danh sách liên kết đơn</p>
                    <img src="~/Image/cir_list.jpg" class="zoom" style="text-align:center" />
                    <br />
                </li>
                <li id="vongdoi_bieudien">
                    <b>Danh sách liên kết vòng đôi</b>
                    <p>Danh sách liên kết vòng đôi được tạo bằng cách thay vì node cuối trỏ vào null thì node cuối trỏ vào head. Thay vì node đầu trỏ vào null thì node đầu trỏ tiếp vào tail</p>
                    <p>Vì vậy, cách khai báo danh sách liên kết vòng đôi sẽ giống như cách khai báo danh sách liên kết đôi</p>
                    <img src="~/Image/cir_dou_list.jpg" class="zoom" style="text-align:center" />
                    <br />
                </li>
            </ul>

        </div>
        <div class="container" id="I_3_4_3">
            <h5>Các hoạt động trên danh sách liên kết vòng</h5>
            <p>Do danh sách liên kết vòng có 2 phần nên phần hoạt động ta cũng chia thành 2 phần:</p>
            <ul>
                <li><a href="#cir_don">Hoạt động trên danh sách liên kết vòng đơn</a></li>
                <li><a href="#cir_doi">Hoạt động trên danh sách liên kết vòng đôi</a></li>
            </ul>
            <hr />
            <div id="cir_don">
                <p><b>Hoạt động trên danh sách liên kết vòng đơn</b></p>
                <p>Sau đây là một số hoạt động trên danh sách liên kết vòng đơn: </p>
                <ul>
                    <li>
                        <a href="#cir_don_insert">Chèn node vào danh sách</a>
                    </li>
                    <li>
                        <a href="#cir_don_remove">Xóa một phần tử trong danh sách</a>
                    </li>
                </ul>
                <hr />
                <div id="cir_don_insert">
                    <p><b>Chèn node vào danh sách liên kết vòng đơn</b></p>
                    <p>Do danh sách liên kết vòng đơn là một danh sách liên kết đơn có con trỏ của node cuối trỏ đến node đầu. Nên nếu ta chèn vào danh sách liên kết vòng thì ta có thể hiểu như <a href="dslk_don_chen_c">chèn vào giữa danh sách liên kết đơn</a> thông thường:</p>
                    <p>Giả sử ta có danh sách liên kết vòng sau:</p>
                    <img src="~/Image/cir_don_insert_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Có r là nút ở giữa danh sách, ở vị trí trước cần chèn. Node cần chèn vào sẽ được chèn phía sau nút r</p>
                    <p>Để chèn vào, ta thực hiện những bước sau:</p>
                    <p>B1: Tạo và cấp phát bộ nhớ cho nút mới</p>
                    <img src="~/Image/cir_don_insert_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B2: Con trỏ next của node mới trỏ vào node next của r</p>
                    <img src="~/Image/cir_don_insert_3.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B3: Cho con trỏ next của r trỏ tới node mới</p>
                    <img src="~/Image/cir_don_insert_4.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Dưới đây là code mẫu:</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Insert_Mid(Node **head, int position, int x){
        int count = 1, found = 0;
        Node* new_node, r;
        r = * head;
        while((r != NULL) && (found ==0)){
            if (count == position){
                struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
                new_node -> data = new_data;
                new_node -> next = r -> next;
                r -> next = q;
                found = 1;
            }
            count ++;
            r = r -> next;
        }
    }</code> </pre>
                    </div><br />
                </div>
                <div id="cir_don_remove">
                    <p><b>Xóa node trong danh sách liên kết vòng đơn</b></p>
                    <p>Do danh sách liên kết vòng đơn là một danh sách liên kết đơn có con trỏ của node cuối trỏ đến node đầu. Nên nếu ta chèn vào danh sách liên kết vòng thì ta có thể hiểu như <a href="dslk_don_xoa_c">xóa phần tử trong danh sách liên kết đơn</a> thông thường:</p>
                    <p>Giả sử ta có danh sách vòng đơn có del là vị trí cần xóa, r là vị trí trước del như sau:</p>
                    <img src="~/Image/cir_don_remove_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Để xóa đi một node trong danh sách liên kết, ta tiến hành những bước sau:</p>
                    <p>B1: Cho con trỏ của nút trước node del trỏ tới nút sau node del</p>
                    <img src="~/Image/cir_don_remove_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B2: Giải phóng bộ nhớ của del</p>
                    <img src="~/Image/cir_don_remove_3.jpg" class="zoom" style="text-align:center" />
                    <br />

                    <p>Dưới đây là code mẫu:</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Remove_Mid(Node **head, int position){
        int count = 1, found = 0;
        Node* del;
        r = *p;
        while((r != NULL) && (found ==0)){
            if (count == position){
                del = r -> next;
                r -> next = del -> next;
                free(del);
                found = 1;
            }
            count ++;
            r = r -> next;
        }
    }</code> </pre>
                    </div><br />
                </div>
            </div>
            <div id="cir_doi">
                <p><b>Hoạt động trên danh sách liên kết vòng đôi</b></p>
                <p>Sau đây là một số hoạt động trên danh sách liên kết vòng đôi: </p>
                <ul>
                    <li>
                        <a href="#cir_doi_insert">Chèn node vào danh sách</a>
                    </li>
                    <li>
                        <a href="#cir_doi_remove">Xóa một phần tử trong danh sách</a>
                    </li>
                </ul>
                <hr />
                <div id="cir_doi_insert">
                    <p><b>Chèn node vào danh sách liên kết vòng đôi</b></p>
                    <p>Do danh sách liên kết vòng đôi là một danh sách liên kết vòng có 2 đầu được nối với nhau nên khi chèn vào danh sách liên kết thì ý tưởng sẽ giống như <a href="#dslk_doi_chen_c">chèn vào giữa danh sách liên kết đôi</a></p>
                    <p>Giả sử ta có danh sách liên kết vòng sau:</p>
                    <img src="~/Image/cir_doi_insert_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Để chèn thêm một node vào danh sách liên kết vòng đôi, ta thực hiện những bước sau:</p>
                    <p>B1: Cấp phát bộ nhớ cho node mới, và truyền dữ liệu vào nó.</p>
                    <img src="~/Image/cir_doi_insert_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B2: Làm cho con trỏ next của node mới trỏ đến con trỏ next của prev_node và con trỏ next của prev_node trỏ đến node mới</p>
                    <img src="~/Image/cir_doi_insert_3.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B3: Làm cho con trỏ prev của node mới được chèn vào trỏ đến node prev_node. Hay nói cách khác là làm cho prev_node trỏ thành node trước đó của node mới và con trỏ prev của con trỏ next của node mới trỏ đến chính node mới</p>
                    <img src="~/Image/cir_doi_insert_4.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Dưới đây là code mẫu theo ngôn ngữ C:</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Insert_Mid(struct Node** head_ref, int new_data) {
        //Kiểm tra xem prev_node nhận vào có NULL hay không, nếu NULL thì return
        if (prev_node == NULL){
            printf("Prev_node khong the NULL");
            return;
        }
        //Tạo node mới và gán dữ liệu vào
        struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
        new_node -> data = new_data;
        
        //Làm cho con trỏ next của node mới trỏ đến con trỏ next của prev_node
        new_node -> next = prev_node -> next;
        
        //Làm cho prev_node trở thành node trước đó của node mới
        prev_node -> next = new_node;
        new_node -> prev = prev_node;

        //Làm cho con trỏ prev của con trỏ next của node mới trỏ đến chính node mới
        if (new_node -> next != NULL)
            new_node -> next -> prev = new_node;        
    }</code> </pre>
                    </div><br />
                </div>
                <div id="cir_doi_remove">
                    <p><b>Xóa node trong danh sách liên kết vòng đôi</b></p>
                    <p>Do danh sách liên kết vòng đôi là một danh sách liên kết vòng có 2 đầu được nối với nhau nên khi xóa phần tử trong danh sách liên kết thì ý tưởng sẽ giống như <a href="#dslk_doi_xoa_c">xóa ở giữa danh sách liên kết đôi</a></p>
                    <p>Giả sử ta có danh sách liên kết sau, với del là node cần xóa:</p>
                    <img src="~/Image/cir_doi_remove_1.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Để xóa node del, ta cần thực hiện những bước sau:</p>
                    <p>B1: Cho con trỏ next của con trỏ phía sau của node cần xóa trỏ về next của node cần xóa</p>
                    <img src="~/Image/cir_doi_remove_2.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>B2: Cho con trỏ prev của con trỏ tiếp theo của node cần xóa trỏ về prev của node cần xóa</p>
                    <img src="~/Image/cir_doi_remove_3.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p> B3: Giải phóng bộ nhớ của Del:</p>/>
                    <img src="~/Image/cir_doi_remove_4.jpg" class="zoom" style="text-align:center" />
                    <br />
                    <p>Dưới đây là code mẫu :</p>
                    <div class="card" style="background-color: #F1F1F1">
<pre style="padding: 1em; margin: .5em 0; overflow: auto;" class="card-body">
                        <code>
    void Remove_Mid(Node** head_ref, Node* del) {
        if (*head_ref == NULL){
            return; //Danh sách rỗng thì returrn 
        }
            
        if (del -> next != NULL){
            del -> next -> prev = del -> prev;
            // (del -> next) là node kế tiếp của node cần xóa
            // (del -> next) -> prev: trỏ prev của node kế tiếp của node cần xóa
        } 

        if (del -> prev != NULL){
            del -> prev -> next = del -> next;
            // (del -> prev) là node trước đó của node cần xóa
            // (del -> prev) -> next: trỏ next của node kế tiếp của node cần xóa
        }

        free(del);
    }</code> </pre>
                    </div><br />
                </div>
            </div>
        </div>
    </div>

</div>

<div>
    <br />
    <br />
    <br />
    <br />
    <br />
    <br />
</div>